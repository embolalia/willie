#!/usr/bin/env python
"""
jenni - An IRC Bot
Copyright 2008, Sean B. Palmer, inamidst.com
Licensed under the Eiffel Forum License 2.

http://inamidst.com/phenny/

Note: DO NOT EDIT THIS FILE.
Run ./jenni, then edit ~/.jenni/default.py
Then run ./jenni again
"""

import sys, os, imp, optparse
from textwrap import dedent as trim

dotdir = os.path.expanduser('~/.jenni')
configpath = os.path.expanduser(dotdir + '/default.py')

def check_python_version():
    if sys.version_info < (2, 6):
        error = 'Error: Requires Python 2.6 or later. Try python2.6 jenni'
        print >> sys.stderr, error
        sys.exit(1)

def create_default_config(fn):
    f = open(fn, 'w')
    #TODO add logchan to config utility
    output = """\
    nick = 'jenni'
    host = 'irc.example.net'
    port = 6667
    channels = ['#example', '#test']
    owner = 'yournickname'
    # Channel where debug messages should be sent.
    devchan = None
    
    # List of other bots, whose outputs should be ignored
    other_bots = ['examplebot']
    logchan_pm = ''

    # password is the NickServ password, serverpass is the server password
    # password = 'example'
    # serverpass = 'serverpass'
    
    # The oper name and password, if the bot is allowed to /oper
    # Oper = ('opername', 'operpass')

    # These are people who will be able to use admin.py's functions...
    admins = [owner, 'someoneyoutrust']
    # But admin.py is disabled by default, as follows:
    exclude = ['admin', 'adminchannel', 'ai', 'resp', 'school']

    # If you want to enumerate a list of modules rather than disabling
    # some, use "enable = ['example']", which takes precedent over exclude
    #
    # enable = []
    
    # Directories to load user modules from
    # e.g. /path/to/my/modules
    extra = ['""" + os.getcwd() + '/modules/' + """']

    # Services to load: maps channel names to white or black lists
    external = {
        '#liberal': ['!'], # allow all
        '#conservative': [], # allow none
        '*': ['!'] # default whitelist, allow all
    }
    
    # Twitter API keys, if you want jenni to be able to tweet.
    # consumer_key = "something"
    # consumer_secret = "somethingelse"
    # access_token = "yetanotherthing"
    # access_token_secret = "onemorething"
    
    # ------------------  USER DATABASE CONFIGURATION  ------------------
    # The user database can hold any user-specific settings you want. For
    # example, this branch has modules which will use a user-specific time zone
    # based on the 'tz' column in the database. The name of the columns used is
    # up to the module writer, who hopefully made provisions for when you don't
    # have that column. In order to use that function, it is up to you to make
    # sure you have the appropriate column in the database.
    # You have an option of using a MySQL or SQLite database, or a native Python
    # dict object. The SQL options can be edited without restarting the bot, and
    # users can edit their entries by themselves, and they can be located on a
    # different machine. However, they may or may not be slower. If you want to
    # have this feature (it's optional), uncomment and  put 'mysql', 'sqlite',
    # or 'native' for this value.

    # userdb_type = 'whatever'
    
    # Each type has to be handled a little differently. For a MySQL database,
    # uncomment and fill in the values below. The database should have a column
    # named 'locales', with a primary key column named 'nick'. You will need to
    # have the MySQLdb module installed to use this option.
    
    # userdb_host = 'localhost'
    # userdb_user = 'username'
    # userdb_pass = 'password'
    # userdb_name = 'database_name'
    
    # For a SQLite database, uncomment and fill in these values:
    
    ####SQLite support is not yet implemented. Sorry.
    
    # For a native dict database, you need to fill in each user manually, like so:
    
    # userdb_data = {
    #                 'someuser':    {'tz': 'America/New_York'}
    #                 'anotheruser': {'icao': 'KCMH'}
    #                 'onemoreuser': {'tz': 'Europe/Berlin', 'icao': 'EDDT'}

    # EOF
    """
    print >> f, trim(output)
    f.close()

def create_configfile(dotdir):

    if not os.path.isdir(dotdir):
        print 'Creating a config directory at ~/.jenni...'
        try: os.mkdir(dotdir)
        except Exception, e:
            print >> sys.stderr, 'There was a problem creating %s:' % dotdir
            print >> sys.stderr, e.__class__, str(e)
            print >> sys.stderr, 'Please fix this and then run jenni again.'
            sys.exit(1)

    create_default_config(configpath)
    print >> sys.stdout, 'Config file generated. Please edit it at ' + configpath + ' and run ./jenni again.'

    sys.exit(0)

def check_dotdir():
    if not os.path.isdir(dotdir) or not os.path.isfile(configpath):
        create_configfile(dotdir)

def config_names(config):
    config = config or 'default'

    def files(d):
        names = os.listdir(d)
        return list(os.path.join(d, fn) for fn in names if fn.endswith('.py'))

    here = os.path.join('.', config)
    if os.path.isfile(here):
        return [here]
    if os.path.isfile(here + '.py'):
        return [here + '.py']
    if os.path.isdir(here):
        return files(here)

    there = os.path.join(dotdir, config)
    if os.path.isfile(there):
        return [there]
    if os.path.isfile(there + '.py'):
        return [there + '.py']
    if os.path.isdir(there):
        return files(there)

    sys.exit(1)

def main(argv=None):
    # Step One: Parse The Command Line

    parser = optparse.OptionParser('%prog [options]')
    parser.add_option('-c', '--config', metavar='fn',
        help='use this configuration file or directory')
    opts, args = parser.parse_args(argv)

    # Step Two: Check Dependencies

    check_python_version() # require python2.4 or later
    check_dotdir() # require ~/.jenni, or make it and exit

    # Step Three: Load The Configurations

    config_modules = []
    for config_name in config_names(opts.config):
        name = os.path.basename(config_name).split('.')[0] + '_config'
        module = imp.load_source(name, config_name)
        module.filename = config_name

        if not hasattr(module, 'prefix'):
            module.prefix = r'\.'

        if not hasattr(module, 'name'):
            module.name = 'Jenni Yanosbot, https://github.com/myano/jenni'

        if not hasattr(module, 'port'):
            module.port = 6667

        if not hasattr(module, 'password'):
            module.password = None

        if module.host == 'irc.example.net':
            error = ('Error: you must edit the config file first!\n' +
                        "You're currently using %s" % module.filename)
            print >> sys.stderr, error
            sys.exit(1)

        config_modules.append(module)

    # Step Four: Load Jenni

    try: from __init__ import run
    except ImportError:
        try: from jenni import run
        except ImportError:
            print >> sys.stderr, "Error: Couldn't find jenni to import"
            sys.exit(1)

    # Step Five: Initialise And Run The Jennies

    # @@ ignore SIGHUP
    for config_module in config_modules:
        run(config_module) # @@ thread this

if __name__ == '__main__':
    main()
